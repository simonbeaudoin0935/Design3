#include "../../inc/Motor/PID.h"
#include "../../inc/Motor/Motor.h"
#include "stm32f4xx.h"
#include "../../inc/define.h"


typedef struct{

	struct{
		float new;
		float old;
	}position;

	struct{
		float new;
		float old;
	}vitesse;


	struct{
		float old;
		float new;
	}consigne_position;

	struct{
		float old;
		float new;
	}consigne_vitesse;

	struct{
		float old;
		float new;
	}erreur_position;

	struct{
		float old;
		float new;
	}erreur_vitesse;

	struct{
		float position;
		float vitesse;
	}integral;


	float pid;
}PID_t;

PID_t PID_1;
PID_t PID_2;
PID_t PID_3;
PID_t PID_4;



void PID_reset(void){

	motor_1.displacement     = 0.0;
	motor_1.speed.new        = 0.0;
	motor_1.speed.old        = 0.0;
	motor_1.acceleration     = 0.0;

	motor_2.displacement     = 0.0;
	motor_2.speed.new        = 0.0;
	motor_2.speed.old        = 0.0;
	motor_2.acceleration     = 0.0;

	motor_3.displacement     = 0.0;
	motor_3.speed.new        = 0.0;
	motor_3.speed.old        = 0.0;
	motor_3.acceleration     = 0.0;

	motor_4.displacement     = 0.0;
	motor_4.speed.new        = 0.0;
	motor_4.speed.old        = 0.0;
	motor_4.acceleration     = 0.0;

	motor_1_pid.consigne_vitesse = 0.05; //m/s
}


void PID_compute(void){

	uint16_t motor_1_tick = TIM1->CNT;
	TIM1->CNT = 32762;
	uint16_t motor_2_tick = TIM2->CNT;
	TIM2->CNT = 32762;
	uint16_t motor_3_tick = TIM3->CNT;
	TIM3->CNT = 32762;
	uint16_t motor_4_tick = TIM4->CNT;
	TIM4->CNT = 32762;

	PID_1.position += ((float)((int)motor_1_tick - 32762)) * TICK_TO_METER;
	PID_1.position += ((float)((int)motor_2_tick - 32762)) * TICK_TO_METER;
	PID_1.position += ((float)((int)motor_3_tick - 32762)) * TICK_TO_METER;
	PID_1.position += ((float)((int)motor_4_tick - 32762)) * TICK_TO_METER;

	PID_1.consigne_vitesse.old = PID_1.consigne_vitesse.new;
	PID_1.erreur_position.old  = PID_1.erreur_position.new;
	PID_1.erreur_position.new  = PID_1.consigne_position.new - PID_1.position;
	PID_1.integral.position   += PID_1.erreur_position.new;
	PID_1.consigne_vitesse.new = PKp * PID_1.erreur_position.new +
								 PKi * PID_1.integral.position   +
								 PKd * (PID_1.erreur_position.new - PID_1.erreur_position.old);

	if(PID_1.consigne_vitesse.new > Vmax){
		PID_1.consigne_vitesse.new = Vmax;
	}else if(PID_1.consigne_vitesse.new < - Vmax){
		PID_1.consigne_vitesse.new = - Vmax;
	}

	if((PID_1.consigne_vitesse.new - PID_1.consigne_vitesse.old) > Amax){
		PID_1.consigne_vitesse.new = PID_1.consigne_vitesse.old + Amax;
	}else if((PID_1.consigne_vitesse.new - PID_1.consigne_vitesse.old) < - Amax){
		PID_1.consigne_vitesse.new = PID_1.consigne_vitesse.old - Amax;
	}

	PID_1.vitesse.new = (PID_1.position.new - PID_1.position.old) / CONTROL_LOOP_INTERVAL;
	PID_1.position.old = PID_1.position.new;

	PID_1.erreur_vitesse.old = PID_1.erreur_vitesse.new;
	PID_1.erreur_vitesse.new = PID_1.consigne_vitesse.new - PID_1.vitesse.new;

	float derivee = (PID_1.erreur_vitesse.new - PID_1.erreur_vitesse.old) / CONTROL_LOOP_INTERVAL;
	PID_1.integral.vitesse += PID_1.erreur_vitesse * CONTROL_LOOP_INTERVAL;
	PID_1.pid = VKp * PID_1.erreur_vitesse.new +
			    VKi * PID_1.integral.vitesse +
				VKd * derivee;


	motor1_set_speed((int)(PID_1.pid));
}
